#pragma config(Sensor, S2,     LeftColor,      sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S1,     RightColor,     sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     Gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S4,     Touch,          sensorEV3_Touch)
#pragma config(Motor,  motorB,          LeftTire,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RightTire,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
bool map[7][5];
bool win;
bool spaces = false;
void DriveIn();
void allSpaces()
{
	for(int x = 0; x < 7; x++)
	{
		for(int y = 0; y < 5; y++)
		{
			if(map[x][y] == false)
			{
				spaces = false;
				x = 7;
				break;
			}
			else
			{
				spaces = true;
			}
		}
	}
}
void GoBack()
{
	setMotorSpeed(LeftTire, 0);
	setMotorSpeed(RightTire, 0);
	setMotorSyncEncoder(LeftTire,RightTire,0,250,-30);
	while(getMotorRunning(LeftTire))
	{
	}
	sleep(100);
}
void GoBackFull()
{
	setMotorSpeed(RightTire, 0);
	setMotorSpeed(LeftTire, 0);
	setMotorSyncEncoder(LeftTire,RightTire,0,700,-30);
	while(getMotorRunning(LeftTire))
	{
		if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] > 2)
		{
			setMotorSpeed(RightTire, 0);
			setMotorSpeed(LeftTire, 0);
			setMotorSpeed(RightTire, -10);
			//	setMotorSpeed(LeftTire, -4);
			while(SensorValue[RightColor] > 2)
			{
			}
			setMotorSpeed(LeftTire, 0);
			setMotorSpeed(RightTire, 0);
		}
		else if(SensorValue[LeftColor] > 2 && SensorValue[RightColor] < 2)
		{
			setMotorSpeed(RightTire, 0);
			setMotorSpeed(LeftTire, 0);
			setMotorSpeed(LeftTire, -10);
			//setMotorSpeed(RightTire, -4);
			while(SensorValue[LeftColor] > 2)
			{
			}
			setMotorSpeed(LeftTire, 0);
			setMotorSpeed(RightTire, 0);
		}
		else if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] < 2)
		{
			setMotorSpeed(RightTire, 0);
			setMotorSpeed(LeftTire, 0);
		}
	}
	sleep(100);
	GoBack();
}
bool checkforred()
{
	resetMotorEncoder(LeftTire);
	resetMotorEncoder(RightTire);
	setMotorSyncEncoder(LeftTire,RightTire,0,100,30);
	while(getMotorRunning(LeftTire))
	{
	}
	sleep(100);
	if(SensorValue[LeftColor] == 5 && SensorValue[RightColor] == 5)
	{
		GoBackFull();
		DriveIn();
		GoBackFull();
		win = true;
		return false;
	}
	else
	{
		return true;
	}
}
void DriveIn()
{
	setMotorSpeed(RightTire, 0);
	setMotorSpeed(LeftTire, 0);
	setMotorSyncEncoder(LeftTire,RightTire,0,700,40);
	while(getMotorRunning(LeftTire))
	{
		if(getTouchValue(Touch) == 1)
		{
			GoBack();
		}
		if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] > 2)
		{
			setMotorSpeed(RightTire, 0);
			setMotorSpeed(LeftTire, 0);
			setMotorSpeed(RightTire, 20);
			setMotorSpeed(LeftTire, -4);
			while(SensorValue[RightColor] > 2)
			{
			}
			setMotorSpeed(LeftTire, 0);
			setMotorSpeed(RightTire, 0);
		}
		else if(SensorValue[LeftColor] > 2 && SensorValue[RightColor] < 2)
		{
			setMotorSpeed(RightTire, 0);
			setMotorSpeed(LeftTire, 0);
			setMotorSpeed(LeftTire, 20);
			setMotorSpeed(RightTire, -4);
			while(SensorValue[LeftColor] > 2)
			{
			}
			setMotorSpeed(LeftTire, 0);
			setMotorSpeed(RightTire, 0);
		}
		else if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] < 2)
		{
			setMotorSpeed(RightTire, 0);
			setMotorSpeed(LeftTire, 0);
		}
	}
	resetMotorEncoder(LeftTire);
	resetMotorEncoder(RightTire);
	setMotorSyncEncoder(LeftTire,RightTire,0,450,40);
	while(getMotorRunning(LeftTire))
	{
	}
}
bool GoToLine(int r, int c)
{
	allSpaces();
	bool temp = true;
	if(win == true || spaces == true)
	{
		return false;
	}
	if(map[r][c]== true)
	{
		if(r+1 < 7)
		{
			if(map[r+1][c]== false)
			{
				if(GoToLine(r+1,c))
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		else if(r- 1 > -1)
		{
			if(map[r-1][c]== false)
			{
				if(GoToLine(r-1,c))
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		else if(c + 1 < 5)
		{
			if(map[r][c+1]== false)
			{
				if(GoToLine(r,c+1))
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		else if( c- 1 > -1 )
		{
			if(map[r][c-1]== false)
			{
				if(GoToLine(r,c-1))
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		else
		{
			return false;
		}
	}
	else
	{
		setMotorSpeed(RightTire, 0);
		setMotorSpeed(LeftTire, 0);
		setMotorSyncEncoder(LeftTire,RightTire,0,1000,30);
		while(getMotorRunning(LeftTire))
		{
			if(getTouchValue(Touch) == 1)
			{
				GoBack();
				return false;
			}
			if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] > 2)
			{
				setMotorSpeed(RightTire, 0);
				setMotorSpeed(LeftTire, 0);
				setMotorSpeed(RightTire, 20);
				setMotorSpeed(LeftTire, -4);
				while(SensorValue[RightColor] > 2)
				{
				}
				setMotorSpeed(LeftTire, 0);
				setMotorSpeed(RightTire, 0);
				temp = checkforred();
				if(temp == true)
				{
					map[r][c] = true;
					GoBack();
					return true;
				}
				else
				{
					return false;
				}
			}
			else if(SensorValue[LeftColor] > 2 && SensorValue[RightColor] < 2)
			{
				setMotorSpeed(RightTire, 0);
				setMotorSpeed(LeftTire, 0);
				setMotorSpeed(LeftTire, 20);
				setMotorSpeed(RightTire, -4);
				while(SensorValue[LeftColor] > 2)
				{
				}
				setMotorSpeed(LeftTire, 0);
				setMotorSpeed(RightTire, 0);
				temp = checkforred();
				if(temp == true)
				{
					map[r][c] = true;
					GoBack();
					return true;
				}
				else
				{
					return false;
				}
			}
			else if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] < 2)
			{
				setMotorSpeed(RightTire, 0);
				setMotorSpeed(LeftTire, 0);
				temp = checkforred();
				if(temp == true)
				{
					map[r][c] = true;
					GoBack();
					return true;
				}
				else
				{
					return false;
				}
			}
		}
	}
	return false;
}
void TurnRight()
{
	setMotorSpeed(RightTire, 0);
	setMotorSpeed(LeftTire, 0);
	int CurGyro = SensorValue[Gyro] + 84;
	setMotorSpeed(LeftTire, 25);
	setMotorSpeed(RightTire, -25);
	while(SensorValue[Gyro] < CurGyro)
	{
	}
	setMotorSpeed(LeftTire, 0);
	setMotorSpeed(RightTire, 0);
	sleep(100);
}
void TurnLeft()
{
	setMotorSpeed(RightTire, 0);
	setMotorSpeed(LeftTire, 0);
	int CurGyro = SensorValue[Gyro] - 84;
	setMotorSpeed(LeftTire, -25);
	setMotorSpeed(RightTire, 25);
	while(SensorValue[Gyro] > CurGyro)
	{
	}
	setMotorSpeed(LeftTire, 0);
	setMotorSpeed(RightTire, 0);
	sleep(100);
}
void checkLeft(int r, int c,int direct,bool &goLeft)
{
	if(direct <1)
	{
		direct = 4;
	}
	if(direct == 1)
	{
		r = r +1;
	}
	else if(direct == 2)
	{
		c = c + 1;
	}
	else if(direct == 3)
	{
		r = r - 1;
	}
	else
	{
		c = c - 1;
	}
	if((direct == 1 && r > 6) || (direct == 2 && c > 4) || (direct == 3 && r < 0) || (direct == 4 && c < 0))
	{
		goLeft = false;
	}
	if(goLeft)
	{
		TurnLeft();
		if(!(GoToLine(r,c)))
		{
			goLeft = false;
		}
		else
		{
			goLeft = true;
		}
		TurnRight();
	}
}
void checkRight(int r, int c,int direct,bool &goRight)
{
	if(direct > 4)
	{
		direct = 1;
	}
	if(direct == 1)
	{
		r = r +1;
	}
	else if(direct == 2)
	{
		c = c + 1;
	}
	else if(direct == 3)
	{
		r = r - 1;
	}
	else
	{
		c = c - 1;
	}
	if((direct == 1 && r > 6) || (direct == 2 && c > 4) || (direct == 3 && r < 0) || (direct == 4 && c < 0))
	{
		goRight = false;
	}
	if(goRight)
	{
		TurnRight();
		if(!GoToLine(r,c))
		{
			goRight = false;
		}
		else
		{
			goRight = true;
		}
		TurnLeft();
	}
}
void checkFront(int r, int c,int direct, bool &goStraight)
{
	if(direct == 1)
	{
		r = r + 1;
	}
	else if(direct == 2)
	{
		c = c + 1;
	}
	else if(direct == 3)
	{
		r = r - 1;
	}
	else
	{
		c = c - 1;
	}
	if((direct == 1 && r > 6) || (direct == 2 && c > 4) || (direct == 3 && r < 0) || (direct == 4 && c < 0))
	{
		goStraight = false;
	}
	if(goStraight)
	{
		if(!GoToLine(r,c))
		{
			goStraight = false;
		}
		else
		{
			goStraight = true;
		}
	}
}
void Maze(int r, int c, int direct)
{
	allSpaces();
	int tempr,tempc,tempdir;
	bool goLeft = true;
	bool goRight = true;
	bool goStraight = true;
	displayCenteredBigTextLine(1, "Row%d",r);
	displayCenteredBigTextLine(3, "Col%d",c);
	displayCenteredBigTextLine(5, "Dir%d",direct);
	if(direct > 4)
	{
		direct = 1;
	}
	if(direct <1)
	{
		direct = 4;
	}
	checkLeft(r,c,direct-1,goLeft);
	checkFront(r,c,direct,goStraight);
	checkRight(r,c,direct+1,goRight);
	if(win == true || spaces == true)
	{
		goLeft = false;
		goRight = false;
		goStraight = false;
	}
	if(goLeft)
	{
		tempr = r;
		tempc = c;
		tempdir = direct;
		direct = direct-1;
		if(direct <1)
		{
			direct = 4;
		}
		if(direct == 1)
		{
			tempr = r + 1;
		}
		else if(direct == 2)
		{
			tempc = c + 1;
		}
		else if(direct == 3)
		{
			tempr = r - 1;
		}
		else
		{
			tempc = c - 1;
		}
		sleep(100);
		TurnLeft();
		DriveIn();
		Maze(tempr , tempc , direct);
		GoBackFull();
		TurnRight();
		direct = tempdir;
		allSpaces();
		if(win == true|| spaces == true)
		{
			goLeft = false;
			goRight = false;
			goStraight = false;
		}
	}
	if(goStraight)
	{
		tempr = r;
		tempc = c;
		if(direct == 1)
		{
			tempr = r + 1;
		}
		else if(direct == 2)
		{
			tempc = c + 1;
		}
		else if(direct == 3)
		{
			tempr = r - 1;
		}
		else
		{
			tempc = c - 1;
		}
		sleep(100);
		DriveIn();
		Maze(tempr , tempc , direct);
		GoBackFull();
		allSpaces();
		if(win == true || spaces == true)
		{
			goLeft = false;
			goRight = false;
			goStraight = false;
		}
	}
	if(goRight)
	{
		tempr = r;
		tempc = c;
		tempdir = direct;
		direct = direct+1;
		if(direct > 4)
		{
			direct = 1;
		}
		if(direct == 1)
		{
			tempr = r + 1;
		}
		else if(direct == 2)
		{
			tempc = c + 1;
		}
		else if(direct == 3)
		{
			tempr = r - 1;
		}
		else
		{
			tempc = c - 1;
		}
		sleep(100);
		TurnRight();
		DriveIn();
		Maze(tempr,tempc,direct);
		GoBackFull();
		TurnLeft();
		direct = tempdir;
		allSpaces();
		if(win == true|| spaces == true)
		{
			goLeft = false;
			goRight = false;
			goStraight = false;
		}
	}
	if(!goLeft  && !goRight && !goStraight)
	{
		allSpaces();
		//go backwards
		//if(r == 0 && c == 0)
		//{
		//}
		//else
		//{
		//	GoBackFull();
		//	sleep(100);
		//}
	}
}
task main()
{
	resetGyro(Gyro);
	map[0][0] = true;
	Maze(0,0,1);
}