#pragma config(Sensor, S2,     LeftColor,      sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S1,     RightColor,     sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     Gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S4,     Touch,          sensorEV3_Touch)
#pragma config(Motor,  motorB,          LeftTire,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          RightTire,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int kushal_length = 7;
const int kushal_width = 5;

const int kushal_initial_length = 0;
const int kushal_initial_width = 0;
const int kushal_initial_direction = 0;

bool map[kushal_length][kushal_width];
bool win;
bool spaces = false;
void DriveIn();

int int_sleep_timer = 100;

void kushal_stop()
{
	setMotorSpeed(RightTire, 0);
	setMotorSpeed(LeftTire, 0);
}

void kushal_reset_motor_encoders()
{
	resetMotorEncoder(LeftTire);
	resetMotorEncoder(RightTire);
}

void allSpaces()
{
	for(int x = 0; x < kushal_length; x++)
	{
		for(int y = 0; y < kushal_width; y++)
		{
			if(map[x][y] == false)
			{
				spaces = false;
				x = kushal_length;
				break;
			}
			else
			{
				spaces = true;
			}
		}
	}
}

void GoBack()
{
	setMotorSyncEncoder(LeftTire,RightTire,0,250,-30);
	while(getMotorRunning(LeftTire)){}
	sleep(int_sleep_timer);
}
void GoBackFull()
{
	kushal_stop();
	setMotorSyncEncoder(LeftTire,RightTire,0,700,-30);
	while(getMotorRunning(LeftTire))
	{
		if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] > 2)
		{
			kushal_stop();
			setMotorSpeed(RightTire, -10);
			while(SensorValue[RightColor] > 2){}
			kushal_stop();
		}
		else if(SensorValue[LeftColor] > 2 && SensorValue[RightColor] < 2)
		{
			kushal_stop();
			setMotorSpeed(LeftTire, -10);
			while(SensorValue[LeftColor] > 2){}
			kushal_stop();
		}
		else if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] < 2)
		{
			kushal_stop();
		}
	}
	sleep(int_sleep_timer);
	GoBack();
}

bool should_i_keep_going()
{
	kushal_reset_motor_encoders();
	setMotorSyncEncoder(LeftTire,RightTire,0,100,30);
	while(getMotorRunning(LeftTire)){}
	sleep(int_sleep_timer);
	if(SensorValue[LeftColor] == 5 && SensorValue[RightColor] == 5)
	{
		GoBackFull();
		DriveIn();
		// i won
		GoBackFull();
		win = true;
		return false;
	}
	else {return true;}
}

void DriveIn()
{
	kushal_stop();
	setMotorSyncEncoder(LeftTire,RightTire,0,700,40);
	while(getMotorRunning(LeftTire))
	{
		if(getTouchValue(Touch) == 1)
		{
			GoBack();
		}
		if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] > 2)
		{
			kushal_stop();
			setMotorSpeed(RightTire, 20);
			setMotorSpeed(LeftTire, -4);
			while(SensorValue[RightColor] > 2)
			{
			}
			kushal_stop();
		}
		else if(SensorValue[LeftColor] > 2 && SensorValue[RightColor] < 2)
		{
			kushal_stop();
			setMotorSpeed(LeftTire, 20);
			setMotorSpeed(RightTire, -4);
			while(SensorValue[LeftColor] > 2){}
			kushal_stop();
		}
		else if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] < 2)
		{
			kushal_stop();
		}
	}
	kushal_reset_motor_encoders();
	setMotorSyncEncoder(LeftTire,RightTire,0,450,40);
	while(getMotorRunning(LeftTire)){}
}

bool GoToLine(int r, int c)
{
	allSpaces();
	bool temp = true;
	if(win == true || spaces == true)
	{
		return false;
	}
	if(map[r][c]== true)
	{
		if(r + 1 < kushal_length)
		{
			if(map[r+1][c]== false)
			{
				if(GoToLine(r+1,c))
				{
					return true;
				}
				else
				{
					return false;
				}

			}
		}
		else if(r - 1 > -1)
		{
			if(map[r - 1][c]== false)
			{
				if(GoToLine(r - 1,c))
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		else if(c + 1 < kushal_width)
		{
			if(map[r][c + 1]== false)
			{
				if(GoToLine(r,c + 1))
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		else if(c - 1 > -1)
		{
			if(map[r][c-1]== false)
			{
				if(GoToLine(r, c-1))
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		else
		{
			return false;
		}
	}
	else
	{
		kushal_stop();
		setMotorSyncEncoder(LeftTire,RightTire,0,1000,30);
		while(getMotorRunning(LeftTire))
		{
			if(getTouchValue(Touch) == 1)
			{
				GoBack();
				return false;
			}
			if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] > 2)
			{
				kushal_stop();
				setMotorSpeed(RightTire, 20);
				setMotorSpeed(LeftTire, -4);
				while(SensorValue[RightColor] > 2){}
				kushal_stop();
				temp = should_i_keep_going();
				if(temp == true)
				{
					map[r][c] = true;
					GoBack();
					return true;
				}
				else
				{
					return false;
				}
			}
			else if(SensorValue[LeftColor] > 2 && SensorValue[RightColor] < 2)
			{
				setMotorSpeed(RightTire, 0);
				setMotorSpeed(LeftTire, 0);
				setMotorSpeed(LeftTire, 20);
				setMotorSpeed(RightTire, -4);
				while(SensorValue[LeftColor] > 2){}
				setMotorSpeed(LeftTire, 0);
				setMotorSpeed(RightTire, 0);
				temp = should_i_keep_going();
				if(temp == true)
				{
					map[r][c] = true;
					GoBack();
					return true;
				}
				else
				{
					return false;
				}
			}
			else if(SensorValue[LeftColor] < 2 && SensorValue[RightColor] < 2)
			{
				setMotorSpeed(RightTire, 0);
				setMotorSpeed(LeftTire, 0);
				temp = should_i_keep_going();
				if(temp == true)
				{
					map[r][c] = true;
					GoBack();
					return true;
				}
				else
				{
					return false;
				}
			}
		}
	}
	return false;
}

void TurnRight()
{
	kushal_stop();
	int CurGyro = SensorValue[Gyro] + 84;
	setMotorSpeed(LeftTire, 25);
	setMotorSpeed(RightTire, -25);
	while(SensorValue[Gyro] < CurGyro){}
	setMotorSpeed(LeftTire, 0);
	setMotorSpeed(RightTire, 0);
	sleep(int_sleep_timer);
}

void TurnLeft()
{
	kushal_stop();
	int CurGyro = SensorValue[Gyro] - 84;
	setMotorSpeed(LeftTire, -25);
	setMotorSpeed(RightTire, 25);
	while(SensorValue[Gyro] > CurGyro){}
	setMotorSpeed(LeftTire, 0);
	setMotorSpeed(RightTire, 0);
	sleep(int_sleep_timer);
}

void checkLeft(int r, int c,int direct,bool &goLeft)
{
	if(direct <1)
	{
		direct = 4;
	}
	if(direct == 1)
	{
		r = r +1;
	}
	else if(direct == 2)
	{
		c = c + 1;
	}
	else if(direct == 3)
	{
		r = r - 1;
	}
	else
	{
		c = c - 1;
	}
	if((direct == 1 && r > 6) || (direct == 2 && c > 4) || (direct == 3 && r < 0) || (direct == 4 && c < 0))
	{
		goLeft = false;
	}
	if(goLeft)
	{
		TurnLeft();
		if(!(GoToLine(r,c)))
		{
			goLeft = false;
		}
		else
		{
			goLeft = true;
		}
		TurnRight();
	}
}

void checkRight(int r, int c,int direct,bool &goRight)
{
	if(direct > 4)
	{
		direct = 1;
	}
	if(direct == 1)
	{
		r = r +1;
	}
	else if(direct == 2)
	{
		c = c + 1;
	}
	else if(direct == 3)
	{
		r = r - 1;
	}
	else
	{
		c = c - 1;
	}
	if((direct == 1 && r > 6) || (direct == 2 && c > 4) || (direct == 3 && r < 0) || (direct == 4 && c < 0))
	{
		goRight = false;
	}
	if(goRight)
	{
		TurnRight();
		if(!GoToLine(r,c))
		{
			goRight = false;
		}
		else
		{
			goRight = true;
		}
		TurnLeft();
	}
}

void checkFront(int r, int c,int direct, bool &goStraight)
{
	if(direct == 1)
	{
		r = r + 1;
	}
	else if(direct == 2)
	{
		c = c + 1;
	}
	else if(direct == 3)
	{
		r = r - 1;
	}
	else
	{
		c = c - 1;
	}
	if((direct == 1 && r > 6) || (direct == 2 && c > 4) || (direct == 3 && r < 0) || (direct == 4 && c < 0))
	{
		goStraight = false;
	}
	if(goStraight)
	{
		if(!GoToLine(r,c))
		{
			goStraight = false;

		}
		else
		{
			goStraight = true;
		}
	}
}

void Maze(int r, int c, int direct)
{
	allSpaces();
	int tempr,tempc,tempdir;
	bool goLeft = true;
	bool goRight = true;
	bool goStraight = true;
	displayCenteredBigTextLine(1, "Row%d",r);
	displayCenteredBigTextLine(3, "Col%d",c);
	displayCenteredBigTextLine(5, "Dir%d",direct);
	if(direct > 4)
	{
		direct = 1;
	}
	if(direct <1)
	{
		direct = 4;
	}
	checkLeft(r,c,direct-1,goLeft);
	checkFront(r,c,direct,goStraight);
	checkRight(r,c,direct+1,goRight);
	if(win == true || spaces == true)
	{
		goLeft = false;
		goRight = false;
		goStraight = false;
	}
	if(goLeft)
	{
		tempr = r;
		tempc = c;
		tempdir = direct;
		direct = direct - 1;
		if(direct <1)
		{
			direct = 4;
		}
		if(direct == 1)
		{
			tempr = r + 1;
		}
		else if(direct == 2)
		{
			tempc = c + 1;
		}
		else if(direct == 3)
		{
			tempr = r - 1;
		}
		else
		{
			tempc = c - 1;
		}
		sleep(int_sleep_timer);
		TurnLeft();
		DriveIn();
		Maze(tempr , tempc , direct);
		GoBackFull();
		TurnRight();
		direct = tempdir;
		allSpaces();
		if(win == true|| spaces == true)
		{
			goLeft = false;
			goRight = false;
			goStraight = false;
		}
	}
	if(goStraight)
	{
		tempr = r;
		tempc = c;
		if(direct == 1)
		{
			tempr = r + 1;
		}
		else if(direct == 2)
		{
			tempc = c + 1;
		}
		else if(direct == 3)
		{
			tempr = r - 1;
		}
		else
		{
			tempc = c - 1;
		}
		sleep(int_sleep_timer);
		DriveIn();
		Maze(tempr , tempc , direct);
		GoBackFull();
		allSpaces();
		if(win == true || spaces == true)
		{
			goLeft = false;
			goRight = false;
			goStraight = false;
		}
	}
	if(goRight)
	{
		tempr = r;
		tempc = c;
		tempdir = direct;
		direct = direct+1;
		if(direct > 4)
		{
			direct = 1;
		}
		if(direct == 1)
		{
			tempr = r + 1;
		}
		else if(direct == 2)
		{
			tempc = c + 1;
		}
		else if(direct == 3)
		{
			tempr = r - 1;
		}
		else
		{
			tempc = c - 1;
		}
		sleep(int_sleep_timer);
		TurnRight();
		DriveIn();
		Maze(tempr,tempc,direct);
		GoBackFull();
		TurnLeft();
		direct = tempdir;
		allSpaces();
		if(win == true|| spaces == true)
		{
			goLeft = false;
			goRight = false;
			goStraight = false;
		}
	}
	if(!goLeft  && !goRight && !goStraight)
	{
		allSpaces();
	}
}

task main()
{
	resetGyro(Gyro);
	map[kushal_initial_length][kushal_initial_width] = true;
	Maze(kushal_initial_length, kushal_initial_width, kushal_initial_direction);
}